
//*******************************************
//  List::Node
//*******************************************

template <class T>
inline
List<T>::Node::Node(const T& data, Node* prev, Node* next)
	: mPrev(prev)
	, mNext(next)
	, mData(data)
{
}

template <class T>
inline
List<T>::EndNode::EndNode()
	: mPrev((Node*)this)
	, mNext((Node*)this)
{
}

//*******************************************
//  List::Iterator
//*******************************************

template <class T>
inline
List<T>::Iterator::Iterator(Node* node)
	: mNode(node)
{
}

template <class T>
inline
typename List<T>::Node*
List<T>::Iterator::getNode() const
{
	return mNode;
}

template <class T>
inline
bool
List<T>::Iterator::operator ==(const Iterator& it) const
{
	return mNode == it.mNode;
}

template <class T>
inline
bool
List<T>::Iterator::operator !=(const Iterator& it) const
{
	return mNode != it.mNode;
}

template <class T>
inline
typename List<T>::Iterator
List<T>::Iterator::operator ++()
{
	mNode = mNode->mNext;
	return (*this);
}

template <class T>
inline
typename List<T>::Iterator
List<T>::Iterator::operator --()
{
	mNode = mNode->mPrev;
	return (*this);
}

//*******************************************
//  List
//*******************************************

template <class T>
inline
List<T>::List()
	: mCount(0)
{
}

template <class T>
inline
List<T>::List(const List& lst)
	: mCount(0)
{
	for(Iterator it=lst.First(); it!=lst.End(); ++it) {
		Append(lst[it]);
	}
}

template <class T>
inline
List<T>&
List<T>::operator = (const List& lst) {
	Clear();
	for(Iterator it=lst.First(); it!=lst.End(); it++) {
		Append(lst[it]);
	}
	return *this;
}

template <class T>
inline
List<T>::~List()
{
	Clear();
}

template <class T>
unsigned
List<T>::Count() const
{
	return mCount;
}

template <class T>
inline
size_t
List<T>::MemoryConsumption()
{
	return sizeof(List) + sizeof(Node) * mCount;
}

template <class T>
inline
bool
List<T>::IsEmpty() const
{
	return !mCount;
}

template <class T>
inline
void
List<T>::Clear()
{
	Node* tmp;
	Node* c = mHead.mNext;
	while (c != (Node*)&mHead) {
		tmp = c;
		c = c->mNext;
		delete tmp;
	}
	mHead.mNext = (Node*)&mHead;
	mHead.mPrev = (Node*)&mHead;
	mCount = 0;
}

template <class T>
inline
void
List<T>::DeleteAll()
{
	Node* tmp;
	Node* c = mHead.mNext;
	while (c != (Node*)&mHead) {
		tmp = c;
		c = c->mNext;
		delete tmp->mData;
		delete tmp;
	}
	mHead.mNext = (Node*)&mHead;
	mHead.mPrev = (Node*)&mHead;
	mCount = 0;
}

template <class T>
inline
void
List<T>::Append(const T& item)
{
	Node*& prev = mHead.mPrev;
	Node* const node = new Node(item, prev, (Node*)&mHead);
	assert(node);
	prev->mNext = node;
	prev = node;
	mCount++;
}

template <class T>
inline
void
List<T>::Prepend(const T& item)
{
	Node*& next = mHead->mPrev;
	Node* const node = new Node(item, mHead, next);
	assert(node);
	next->mPrev = node;
	next = node;
	mCount++;
}

template <class T>
inline
void
List<T>::InsertAfter(const Iterator& it, const T& item)
{
	Node*& next = it.mNode->mPrev;
	Node* const node = new Node(item, it.mNode, next);
	assert(node);
	next->mPrev = node;
	next = node;
	mCount++;
}

template <class T>
inline
void
List<T>::InsertBefore(const Iterator& it, const T& item)
{
	Node*& prev = it.mNode->mPrev;
	Node* const node = new Node(item, prev, it.mNode);
	assert(node);
	prev->mNext = node;
	prev = node;
	mCount++;
}

template <class T>
inline
void
List<T>::RemoveAt(const Iterator& it)
{
	assert(it!=End());
	Node* const next = it.getNode()->mNext;
	Node* const prev = it.getNode()->mPrev;
	prev->mNext = next;
	next->mPrev = prev;
	delete it.getNode();
	mCount--;
}

template <class T>
inline
T&
List<T>::operator[](const Iterator& it)
{
	assert(it!=End());
	return it.getNode()->mData;
}

template <class T>
inline
const T&
List<T>::operator[](const Iterator& it) const
{
	assert(it!=End());
	return it.getNode()->mData;
}

template <class T>
inline
typename List<T>::Iterator
List<T>::FindFirst(const T& item) const
{
	Iterator it = First();
	for(; it != End(); ++it) {
		if (it.getNode()->mData == item)
			break;
	}
	return it;
}

template <class T>
inline
typename List<T>::Iterator
List<T>::FindLast(const T& item) const
{
	Iterator it = Last();
	for(; it != End(); it--) {
		if (it.getNode()->mData == item)
			break;
	}
	return it;
}

template <class T>
inline
typename List<T>::Iterator
List<T>::First() const{
	return Iterator(mHead.mNext);
}

template <class T>
inline
typename List<T>::Iterator
List<T>::Last() const{
	return Iterator(mHead.mPrev);
}

template <class T>
inline
typename List<T>::Iterator
List<T>::End() const{
	return Iterator((Node*)&mHead);
}
